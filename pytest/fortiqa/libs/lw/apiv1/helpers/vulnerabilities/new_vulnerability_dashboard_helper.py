import json
import logging
import time

from datetime import datetime, timedelta
from copy import deepcopy
from typing import Any, Dict
from fortiqa.libs.lw.apiv1.api_client.new_vuln.new_vuln import NewVulnerability
from fortiqa.libs.lw.apiv1.api_client.new_vuln.payloads import ResourceTypes, HostFilter, VulnFilter, PackageFilter, ImageFilter

logger = logging.getLogger(__name__)


class NewVulnerabilityDashboardHelper:
    def __init__(self, user_api, agent_deployment_timestamp: datetime = datetime.now()):
        self.user_api = user_api
        start_date = agent_deployment_timestamp - timedelta(hours=7)
        end_date = agent_deployment_timestamp + timedelta(hours=7)
        self.payload_template: Dict[str, Any] = {
            "paramInfo": [
                {
                    "name": "StartTimeRange",
                    "value": int(start_date.timestamp() * 1000.0),
                },
                {
                    "name": "EndTimeRange",
                    "value": int(end_date.timestamp() * 1000.0)
                }
            ],
            "namedSets": ResourceTypes.all_resource_types(),
            "orders": [
                {
                    "field": "LAST_EVAL_TIME",
                    "order": "desc"
                }
            ]
        }

    def fetch_all_hosts(self) -> list:
        """Helper function to fetch all hosts inside Vulnerability Dashboard"""
        logger.debug("fetch_all_aws_hosts()")
        payload = deepcopy(self.payload_template)
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"All vulnerable hosts: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_host_by_hostname(self, hostname: str, operator: str = "equal") -> list:
        """
        Helper function to fetch detail vulnerability and host info by hostname and operator

        :param hostname: Hostname
        :param operator: Define the operator, e.g. "equal", "starts_with", "ends_with", "not_equal", and "contains"
        :return: List of dictionary contains all info about the matched hosts, and their vulnerabilities
        """
        logger.debug(f"fetch_host_vulnerability_by_host_name() for {hostname}")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.HOST_NAME
        }
        match operator:
            case "equal":
                filter['type'] = "in"
                filter['values'] = [hostname]
            case "starts_with":
                filter['type'] = "ilike"
                filter['value'] = f"{hostname}*"
            case "ends_with":
                filter['type'] = "ilike"
                filter['value'] = f"*{hostname}"
            case "contains":
                filter['type'] = "ilike"
                filter['value'] = f"*{hostname}*"
            case "not_equal":
                filter['type'] = "ne"
                filter["value"] = hostname
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"All vulnerable hosts {operator} {hostname}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_host_by_instance_id(self, instance_id: str) -> list:
        """
        Helper function to fetch detail vulnerability and host info by instance_id.

        :param instance_id: instance_id
        :return: List contains dictionary representing all info about the host, and its vulnerabilities
        """
        logger.debug(f"fetch_host_by_instance_id() for {instance_id}")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.MACHINE_TAGS,
            "jpath": "InstanceId",
            "type": "eq",
            "value": instance_id
        }
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for {instance_id}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_host_by_public_ip(self, public_ip: str) -> list:
        """
        Helper function to fetch detail vulnerability and host info by public_ip.

        :param public_ip: Public IP of the instance
        :return: List contains dictionary representing all info about the host, and its vulnerabilities
        """
        logger.debug(f"fetch_host_by_public_ip({public_ip=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.EXTERNAL_IP,
            "type": "in",
            "values": [public_ip]
        }
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for instance with {public_ip=}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_host_by_private_ip(self, private_ip: str) -> list:
        """
        Helper function to fetch detail vulnerability and host info by private_ip.

        :param private_ip: Private IP of the instance
        :return: List contains dictionary representing all info about the host, and its vulnerabilities
        """
        logger.debug(f"fetch_host_by_private_ip({private_ip=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.INTERNAL_IP,
            "type": "in",
            "values": [private_ip]
        }
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for instance with {private_ip=}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_host_by_machine_id(self, machine_id: str) -> list:
        """
        Helper function to fetch detail vulnerability and host info by Machine ID.

        :param machine_id: Machine ID of the host in Lacework
        :return: List contains dictionary representing all info about the host, and its vulnerabilities
        """
        logger.debug(f"fetch_host_by_machine_id({machine_id=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.MACHINE_ID,
            "type": "in",
            "values": [machine_id]
        }
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for instance with {machine_id=}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_hosts_by_os_type(self, os_type: str) -> list:
        """
        Helper function to fetch detail hosts and their vulnerabilities info by OS type.

        :param os_type: Windows or Linux
        :return: List contains dictionary representing all info about the host, and its vulnerabilities
        """
        logger.debug(f"fetch_hosts_by_os_type({os_type=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.OS_TYPE,
            "type": "in",
            "values": [os_type]
        }
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for instance of {os_type=}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_hosts_with_cve_id(self, cve_id: str) -> list:
        """
        Helper function to fetch detail hosts that have specific CVE ID vulnerability.

        :param cve_id: Vulnerability ID, e.g. "CVE-2005-1119"
        :return: List of dictionary contains all info about the matched hosts, and their vulnerabilities
        """
        logger.debug(f"fetch_hosts_with_cve_id({cve_id=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": VulnFilter.VULN_ID,
            "type": "in",
            "values": [cve_id]
        }
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for instance with {cve_id=}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_hosts_with_package_found(self, package_name: str, operator: str = "in") -> list:
        """
        Helper function to fetch detail hosts that have specific package found.

        :param package_name: Package name, e.g. "apache-log4j1.2"
        :return: List of dictionary contains all info about the matched hosts, and their vulnerabilities
        """
        logger.debug(f"fetch_hosts_with_package_found({package_name=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": PackageFilter.PACKAGE_NAME
        }
        match operator:
            case "in":
                filter['type'] = "in"
                filter['values'] = [package_name]
            case "starts_with":
                filter['type'] = "ilike"
                filter['value'] = f"{package_name}*"
            case "ends_with":
                filter['type'] = "ilike"
                filter['value'] = f"*{package_name}"
            case "contains":
                filter['type'] = "ilike"
                filter['value'] = f"*{package_name}*"
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_host(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Vulnerability for instance with {package_name=}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def wait_until_instance_has_vuln_summary(self, instance_id, wait_until: int):
        """
        Wait for agent host to be returned by new vulnerability API.

        :param instance_id: instance_id
        """
        logger.debug(f'Wait until {instance_id} has vulnerability summary')
        agent_found = False
        first_try = True
        vuln_stats = []
        while first_try or (time.monotonic() < wait_until and not agent_found):
            if not first_try:
                time.sleep(240)
            first_try = False
            vuln_stats = self.fetch_host_by_instance_id(instance_id)
            if type(vuln_stats) is list and len(vuln_stats) == 1:
                logger.debug(f'Found agent host {instance_id} in {vuln_stats}, current time is {datetime.now()}')
                agent_found = True
        if not agent_found:
            raise TimeoutError(
                f'Agent host {instance_id} was not returned by Vulnerability dashboard APIs.'
                f'Current time {datetime.now()}'
                f'Last API response: {vuln_stats}.'
            )

    def wait_until_instance_has_vuln_count(self, instance_id, wait_until: int):
        """
        Wait for agent host has more than 0 vulnerabilities.

        :param instance_id: instance_id
        """
        vuln_found = False
        first_try = True
        vuln_stats = []
        total_vuln = None
        vuln_data_returned = False
        start_time = time.monotonic()
        while first_try or (time.monotonic() < wait_until and not vuln_data_returned):
            if not first_try:
                time.sleep(240)
            first_try = False
            vuln_stats = self.fetch_host_by_instance_id(instance_id)
            if type(vuln_stats) is list and len(vuln_stats) == 1:
                vuln_data_returned = True
                data = vuln_stats[0]
                total_vuln = sum(value for key, value in data.items() if key.startswith("VULN_COUNT_"))
                if total_vuln > 0:
                    logger.debug(f'Found {total_vuln} vulnerabilities for agent host {instance_id}')
                    vuln_found = True
                    time_passed = int(time.monotonic() - start_time)
                    logger.debug(f"Host {instance_id} was found vulnerable after {time_passed} secs")
        if not vuln_data_returned:
            raise TimeoutError(
                f'Agent host {instance_id} has no vulnerability summary returned.'
                f'Last API response: {vuln_stats}.'
            )
        elif not vuln_found:
            raise TimeoutError(
                f'Agent host {instance_id} has 0 vulnerabilities.'
                f'Last API response: {vuln_stats}.'
            )

    def fetch_packages_associate_with_host_by_instance_id(self, instance_id: str) -> list:
        """
        Helper function to fetch all packages found while scanning a specific host.

        :param instance_id: Instance ID
        :return: List of dictionary contains all info about the matched hosts, and their package info
        """
        logger.debug(f"fetch_packages_associate_with_host_by_instance_id({instance_id=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.MACHINE_TAGS,
            "jpath": "InstanceId",
            "type": "eq",
            "value": instance_id
        }
        payload['filters'] = [filter]
        payload['orders'][0]['field'] = "LAST_DISCOVERED_TIME"
        response = NewVulnerability(self.user_api).query_packages(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Package info for {instance_id}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_packages_associate_specifically_with_host_by_instance_id(self, instance_id: str) -> list:
        """
        Helper function to fetch all packages found while scanning a specific host.

        :param instance_id: Instance ID
        :return: List of dictionary contains all info about the matched hosts, and their package info
        """
        logger.debug(f"fetch_packages_associate_specifically_with_host_by_instance_id({instance_id=})")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.MACHINE_TAGS,
            "jpath": "InstanceId",
            "type": "eq",
            "value": instance_id
        }
        payload['filters'] = [filter]
        payload['orders'][0]['field'] = "LAST_DISCOVERED_TIME"
        response = NewVulnerability(self.user_api).query_packages_specifically(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"Package info for {instance_id}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_packages_associate_with_host_by_hostname(self, hostname: str, operator: str = "equal") -> list:
        """
        Helper function to fetch detail package info found while scanning a host by hostname and operator

        :param hostname: Hostname
        :param operator: Define the operator, e.g. "equal", "starts_with", "ends_with" and "contains"
        :return: List of dictionary contains all info about the matched hosts, and their package info
        """
        logger.debug(f"fetch_packages_associate_with_host_by_hostname() for {hostname}")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": HostFilter.HOST_NAME
        }
        match operator:
            case "equal":
                filter['type'] = "in"
                filter['values'] = [hostname]
            case "starts_with":
                filter['type'] = "ilike"
                filter['value'] = f"{hostname}*"
            case "ends_with":
                filter['type'] = "ilike"
                filter['value'] = f"*{hostname}"
            case "contains":
                filter['type'] = "ilike"
                filter['value'] = f"*{hostname}*"
        payload['filters'] = [filter]
        response = NewVulnerability(self.user_api).query_packages(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"All package found {operator} {hostname}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_all_container_images(self) -> list:
        """Helper function to fetch all container images without any filter inside new Vulnerability dashboard"""
        logger.debug("fetch_all_container_images()")
        payload = deepcopy(self.payload_template)
        payload['orders'][0]['field'] = "LAST_SCAN_TIME"
        response = NewVulnerability(self.user_api).query_images(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"All Images found: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def fetch_container_images_by_tag(self, image_tag: str, operator: str = "equal") -> list:
        """
        Helper function to fetch detail container image info by image_tag and operator

        :param image_tag: Image Tag
        :param operator: Define the operator, e.g. "equal", "not_equal_to", "starts_with", "ends_with" and "contains"
        :return: List of dictionary contains all info about the image info
        """
        logger.debug(f"fetch_container_images_by_tag() for {image_tag}")
        payload = deepcopy(self.payload_template)
        filter: Dict[str, Any] = {
            "field": ImageFilter.IMAGE_TAGS
        }
        match operator:
            case "equal":
                filter['type'] = "in"
                filter['values'] = [image_tag]
            case "starts_with":
                filter['type'] = "ilike"
                filter['value'] = f"{image_tag}*"
            case "ends_with":
                filter['type'] = "ilike"
                filter['value'] = f"*{image_tag}"
            case "contains":
                filter['type'] = "ilike"
                filter['value'] = f"*{image_tag}*"
            case "not_equal_to":
                filter['type'] = "ne"
                filter['value'] = image_tag
        payload['filters'] = [filter]
        payload['orders'][0]['field'] = "LAST_SCAN_TIME"
        response = NewVulnerability(self.user_api).query_images(payload=payload)
        assert response.status_code == 200, f"Failed to execute the query, error: {response.text}"
        logger.debug(f"All Images found {operator} {image_tag}: {json.dumps(response.json(), indent=2)}")
        return response.json()['data']

    def wait_until_image_tag_appear_in_new_vuln_page(self, image_registry: str, ecr_repo: str, image_tag: str, timeout: int = 1800) -> bool:
        """Waits for an image tag appear inside Container Vulnerability.

        Args:
            image_registry: Image registry in format of xxxx.dkr.ecr.us-west-1.amazonaws.com,
            ecr_repo: The ECR repo name inside AWS
            image_tag: The image tag used when pushing to ECR that needed to be found
            timeout: Max time until we wait for the image tag to be found to Lacework.

        Returns: True if found, False otherwise
        """
        image_found = False
        start_time = time.monotonic()
        timed_out = False
        while not timed_out and not image_found:
            time_passed = time.monotonic() - start_time
            timed_out = (time_passed > timeout)
            container_vuln_summary = self.fetch_all_container_images()
            for data in container_vuln_summary:
                if image_registry in data['IMAGE_REGISTRIES'] and ecr_repo in data['IMAGE_REPOSITORIES'] and image_tag in data['IMAGE_TAGS']:
                    image_found = True
            if not image_found:
                time.sleep(120)
        if not image_found:
            logger.error(
                f'Image with tag {image_tag} in {ecr_repo} of {image_registry} was not returned by API'
                f'Last Container Vuln Summary: {container_vuln_summary}'
            )
            return False
        logger.debug(f"It took {time_passed} seconds until the image {image_tag} appears inside New Vulnerability dashboard")
        return True

    def wait_until_instance_change_to_agent_and_agentless_coverage_type(self, instance_id: str, wait_until: int):
        """Wait for agent host changes to agent and agentless scanning type"""
        logger.debug(f'Wait until {instance_id} changes to agent and agentless scanning type')
        coverage_type_changed = False
        first_try = True
        while first_try or (time.monotonic() < wait_until and not coverage_type_changed):
            if not first_try:
                time.sleep(240)
            first_try = False
            host_info = self.fetch_host_by_instance_id(instance_id=instance_id)
            data = host_info[0]
            coverage_type = data.get("COVERAGE_TYPE")
            if coverage_type == "Agent and Agentless":
                coverage_type_changed = True
                break
        if not coverage_type_changed:
            raise TimeoutError(
                f'Agent host {instance_id} was not changed to Agent and Agentless scanned'
                f'Current time {datetime.now()}'
                f'Last API response: {host_info}.'
            )

    def wait_until_package_appears_for_host(self, package_name: str, instance_id: str, wait_until: int):
        """Wait for agent host has a specific package scanned"""
        logger.debug(f'Wait until {package_name} scanned for {instance_id}')
        found_package = False
        first_try = True
        while first_try or (time.monotonic() < wait_until and not found_package):
            if not first_try:
                time.sleep(240)
            first_try = False
            packages = self.fetch_packages_associate_with_host_by_instance_id(instance_id=instance_id)
            for package in packages:
                if package['PACKAGE_NAME'] == package_name:
                    found_package = True
                    break
        if not found_package:
            raise TimeoutError(
                f'{package_name} did not appear for agent host {instance_id}'
                f'Current time {datetime.now()}'
                f'Last API response: {packages}.'
            )

    def wait_until_package_active_for_host(self, package_name: str, instance_id: str, wait_until: int):
        """Wait for agent host has a specific package scanned and with status Active"""
        logger.debug(f'Wait until {package_name} active for {instance_id}')
        package_active = False
        first_try = True
        while first_try or (time.monotonic() < wait_until and not package_active):
            if not first_try:
                time.sleep(240)
            first_try = False
            packages = self.fetch_packages_associate_specifically_with_host_by_instance_id(instance_id=instance_id)
            for package in packages:
                if package['PACKAGE_NAME'] == package_name and package['PACKAGE_STATUS'] == 1:
                    package_active = True
                    break
        if not package_active:
            raise TimeoutError(
                f'{package_name} did not change to Active for agent host {instance_id}'
                f'Current time {datetime.now()}'
                f'Last API response: {packages}.'
            )

    def wait_until_host_is_added(self, instance_id: str, wait_until: int):
        """Wait for a host appears in the New Vuln Dashboard"""
        logger.debug(f'Wait until {instance_id} is added to the new Vuln Dashboard')
        host_added = False
        first_try = True
        while first_try or (time.monotonic() < wait_until and not host_added):
            if not first_try:
                time.sleep(240)
            first_try = False
            fetched_host = self.fetch_host_by_instance_id(instance_id=instance_id)
            if fetched_host and fetched_host[0]['MACHINE_TAGS']['InstanceId'] == instance_id:
                host_added = True
        if not host_added:
            raise TimeoutError(
                f'{host_added} is not added to the New Vuln Dashboard'
                f'Current time {datetime.now()}'
                f'Last API response: {fetched_host}.'
            )
